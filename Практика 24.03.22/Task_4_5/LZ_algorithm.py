# LZ-78. Идея -> Изначально словарь пуст, а алгоритм пытается закодировать первый символ.
# На каждой итерации мы пытаемся увеличить кодируемый префикс, пока такой префикс есть в словаре.
# Кодовые слова такого алгоритма будут состоять из двух частей —
# номера в словаре самого длинного найденного префикса и символа,
# который идет за этим префиксом. При этом после кодирования такой
# пары префикс с приписанным символом добавляется в словарь, а алгоритм продолжает кодирование со следующего символа.


def get_LZ78_code(string):
    buffer = ""  # текущий префикс
    result = []
    alphabet_dict = {"": 0}
    for i in string:
        if buffer + i in alphabet_dict:  # Проверка на увеличение префикса
            buffer += i
        else:
            result.append((alphabet_dict[buffer], i))  # добавляем пару в ответ
            alphabet_dict[buffer + i] = max(list(alphabet_dict.values())) + 1  # добавляем сочетание в словарь
            buffer = ""  # обнуляем префикс
    if buffer != "":  # Нужно обработать крайний случай если последнее слово собирается со самого конца строки
        last_symbol = buffer[-1]  # берем последний символ буффера, как новый символ
        # добавляем пару без последнего символа и сам символ в ответ
        result.append((alphabet_dict[buffer[:-1]], last_symbol))
    return result


def decode_LZ78_code(codes):
    alphabet_dict = {0: ""}  # словарь, слово с номером 0 — пустая строка
    result = ""
    for code in codes:
        word = alphabet_dict[code[0]] + code[1]  # составляем сочетание из уже известного в словаре и новой буквы
        result += word  # добавляем к ответу
        alphabet_dict[len(alphabet_dict.values())] = word  # добавляем сочетание в словарь
    return result
